<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Hoola (훌라) — 2.5D 멀티플 MVP</title>
<style>
  :root{
    --bg:#0a1224; --ink:#f7f8ff; --muted:#aab2d5; --primary:#86a8ff; --accent:#ffd1e8;
    --ok:#8be28b; --warn:#ffc66b; --danger:#ff7b8a; --card:#fff; --shadow:0 12px 28px rgba(10,14,40,.25),0 2px 8px rgba(10,14,40,.2);
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0; color:var(--ink); background:
    radial-gradient(1200px 600px at 10% -10%, rgba(120,140,255,.25) 0%, transparent 60%),
    radial-gradient(900px 480px at 110% 0%, rgba(255,120,200,.2) 0%, transparent 60%), var(--bg); font-family:ui-rounded,system-ui,Apple SD Gothic Neo,Pretendard,Segoe UI,Roboto,sans-serif}
  .app{display:grid; grid-template-rows:auto 1fr auto; gap:14px; height:100%; max-width:1200px; margin:0 auto; padding:14px}
  header{display:flex; align-items:center; justify-content:space-between; gap:8px}
  h1{margin:0; font-size:18px; letter-spacing:.2px}
  .opts{display:flex; gap:10px; align-items:center; color:var(--muted); flex-wrap:wrap}
  .board{display:grid; grid-template-columns: 1fr 320px; gap:16px; min-height:0}
  .table{position:relative; background:linear-gradient(180deg,rgba(255,255,255,.04),rgba(255,255,255,.02)); border:1px solid rgba(255,255,255,.08);
    border-radius:24px; padding:14px; box-shadow:var(--shadow); overflow:auto}
  .right{display:flex; flex-direction:column; gap:12px; min-height:0}
  .panel{background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.1); border-radius:20px; padding:12px; box-shadow:var(--shadow)}
  .zones{display:grid; grid-template-columns: repeat(3, 1fr); gap:12px}
  .zone{background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.08); border-radius:18px; padding:10px; min-height:110px}
  .zone h3{margin:0 0 6px 0; font-size:12px; color:var(--muted); text-transform:uppercase; letter-spacing:.6px}
  .cards{display:flex; align-items:flex-end; flex-wrap:wrap; gap:8px}
  .card{width:70px; height:98px; border-radius:14px; background:var(--card); color:#1b2235; box-shadow:var(--shadow);
    display:grid; place-items:center; position:relative; cursor:pointer; transition:.25s transform, .25s box-shadow, .25s opacity; user-select:none}
  .card:hover{transform:translateY(-6px) rotate(-.6deg)}
  .rank{font-weight:900; font-size:22px}
  .suit{font-size:18px}
  .red{color:#e34d5c} .black{color:#2b2f3a}
  .selected{outline:3px solid var(--primary); outline-offset:0}
  .meld{padding:12px; border-radius:14px; background:rgba(255,255,255,.6); color:#101626; box-shadow:var(--shadow)}
  .meld .cards{gap: -46px}
  .meld .card{transform:rotate(0)}
  .hand{position:sticky; bottom:0}
  .hud{display:flex; flex-wrap:wrap; gap:8px}
  button{appearance:none; border:none; background:var(--ink); color:#0c1428; padding:10px 12px; border-radius:14px; font-weight:800; cursor:pointer; box-shadow:var(--shadow)}
  button.ghost{background:transparent; color:var(--ink); border:2px solid rgba(255,255,255,.22)}
  button:disabled{opacity:.45; cursor:not-allowed}
  .badge{display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border-radius:999px; background:rgba(255,255,255,.08); border:1px solid rgba(255,255,255,.14); font-size:12px; color:var(--muted)}
  .pill{display:inline-block; padding:3px 8px; border-radius:999px; background:rgba(255,255,255,.1); color:#bcd2ff; font-weight:700}
  .log{font-size:12px; color:#d2d8ff; max-height:180px; overflow:auto}
  .toast{position:fixed; right:16px; bottom:16px; background:#111827; color:#fff; padding:10px 12px; border-radius:12px; opacity:.95; animation:slideup .25s ease; display:none}
  @keyframes slideup{from{transform:translateY(12px); opacity:0} to{transform:translateY(0); opacity:1}}
  @keyframes drop{from{transform:translateY(-10px); opacity:.6} to{transform:translateY(0); opacity:1}}
  .enter{animation:drop .2s ease}
  .flycard{position:fixed; pointer-events:none; z-index:9999; width:70px; height:98px; border-radius:14px; background:#fff; box-shadow:var(--shadow); display:grid; place-items:center; transition:transform .28s ease, opacity .28s ease}
  .flyrank{font-weight:900; font-size:22px}
  .flysuit{font-size:18px}
  /* table seating */
  .ring{display:grid; grid-template-columns: repeat(4, 1fr); gap:8px}
  .seat{display:flex; align-items:center; justify-content:space-between; padding:8px 10px; border-radius:12px; background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.12)}
  .seat .name{font-weight:800}
  .drag-hint{font-size:12px; color:var(--muted)}
  @media (max-width: 980px){ .board{grid-template-columns: minmax(0,1fr)} .right{order:-1} .zones{grid-template-columns: repeat(2,1fr)} }
  @media (max-width: 680px){ .zones{grid-template-columns: 1fr} .card{width:64px; height:90px} .meld .cards{gap:-40px} }
</style>
</head>
<body>
<div class="app">
  <header>
    <h1>Hoola · 2.5D 멀티플</h1>
    <div class="opts">
      <label><input type="checkbox" id="opt-continue" checked/> 아웃 후 계속</label>
      <span class="badge" id="turnBadge">턴: -</span>
      <span class="badge" id="netBadge">오프라인</span>
      <button id="btnReset" class="ghost">새 게임</button>
    </div>
  </header>

  <div class="board">
    <div class="table" id="table">
      <div class="zones">
        <div class="zone" id="deckZone">
          <h3>DECK</h3>
          <div class="cards" id="deckCount"></div>
          <div class="hud"><button id="btnDraw">드로우</button><button id="btnTY" class="ghost">땡큐</button></div>
        </div>
        <div class="zone" id="discardZone">
          <h3>DISCARD</h3>
          <div class="cards" id="discardCards"></div>
        </div>
        <div class="zone" id="infoZone">
          <h3>INFO</h3>
          <div class="log" id="log" aria-live="polite"></div>
        </div>
      </div>

      <div style="height:10px"></div>
      <div class="panel">
        <h3 style="margin:0 0 6px 0;color:var(--muted)">TABLE MELDS</h3>
        <div id="melds" style="display:grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap:12px"></div>
      </div>

      <div style="height:10px"></div>
      <div class="panel hand">
        <div style="display:flex; align-items:center; justify-content:space-between; gap:8px">
          <div>
            <h3 style="margin:0;color:var(--muted)">YOUR HAND</h3>
            <div class="drag-hint">손패를 드래그해서 순서 바꾸기 · 더블클릭으로 버릴 카드 선택</div>
          </div>
          <div class="hud">
            <button id="btnRegSet" class="ghost">세트 등록</button>
            <button id="btnRegRun" class="ghost">런 등록</button>
            <button id="btnAttach" class="ghost">붙이기</button>
            <button id="btnDiscard" style="background:var(--danger)" disabled>버리고 종료</button>
          </div>
        </div>
        <div class="cards" id="hand"></div>
      </div>
    </div>

    <aside class="right">
      <div class="panel">
        <div style="display:flex; align-items:center; justify-content:space-between">
          <strong>Players</strong>
          <span class="pill" id="roundInfo">R1</span>
        </div>
        <div id="players" class="ring"></div>
      </div>

      <div class="panel">
        <strong>Finish Order</strong>
        <ol id="finish"></ol>
      </div>

      <div class="panel">
        <strong>온라인 플레이 (P2P)</strong>
        <div style="display:flex; gap:8px; margin:8px 0">
          <button id="btnHost" class="ghost">호스트</button>
          <button id="btnJoin" class="ghost">게스트</button>
        </div>
        <small style="color:var(--muted)">SDP를 복사/붙여넣기해서 연결 (서버 없이 P2P, STUN 포함)</small>
        <div style="margin-top:8px">
          <textarea id="sdpIn" placeholder="상대 코드 붙여넣기" style="width:100%; height:80px; border-radius:12px; padding:8px; border:1px solid rgba(255,255,255,.2); background:rgba(0,0,0,.2); color:#fff"></textarea>
          <textarea id="sdpOut" placeholder="내 코드" style="width:100%; height:80px; border-radius:12px; padding:8px; border:1px solid rgba(255,255,255,.2); background:rgba(0,0,0,.2); color:#fff; margin-top:6px" readonly></textarea>
          <div style="display:flex; gap:6px; margin-top:6px">
            <button id="btnApply" class="ghost">코드 적용</button>
          </div>
        </div>
      </div>
    </aside>
  </div>

  <footer style="display:flex; align-items:center; justify-content:space-between; color:var(--muted)">
    <div>MVP: 규칙(드로우/땡큐 → 등록/붙이기 → 버리기), 7 단독 등록, 런 양끝만 붙이기</div>
    <div class="badge">Replit Friendly · Single File</div>
  </footer>
</div>

<div class="toast" id="toast" role="status" aria-live="polite"></div>

<script>
/* ========= Card / Deck ========= */
const SUITS = ['♠','♥','♦','♣'];
const RANKS = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
const isRed = s => s==='♥' || s==='♦';
function buildDeck(){
  const deck=[]; let id=0;
  for(const s of SUITS){ for(const r of RANKS){ deck.push({ id: String(id++), suit: s, rank: r }); } }
  return shuffle(deck);
}
function shuffle(a){ for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]];} return a; }
function rankValue(r){ if(r==='A') return 1; if(r==='J') return 11; if(r==='Q') return 12; if(r==='K') return 13; return parseInt(r,10); }
function sortByRank(cards){ return [...cards].sort((a,b)=>rankValue(a.rank)-rankValue(b.rank)); }

/* ========= Meld validation ========= */
function isSet(cards){ if(cards.length<3) return false; const r=cards[0].rank; return cards.every(c=>c.rank===r); }
function isRun(cards){
  if(cards.length<3) return false; const suit=cards[0].suit; if(!cards.every(c=>c.suit===suit)) return false;
  const asc = sortByRank(cards);
  let ok=true; for(let i=1;i<asc.length;i++){ if(rankValue(asc[i].rank)!==rankValue(asc[i-1].rank)+1){ ok=false; break; } }
  if(ok) return true;
  // Ace high
  const mapH = x=> x.rank==='A'?14:rankValue(x.rank);
  const s2=[...cards].sort((a,b)=>mapH(a)-mapH(b));
  ok=true; for(let i=1;i<s2.length;i++){ if(mapH(s2[i])!==mapH(s2[i-1])+1){ ok=false; break; } }
  return ok;
}
function classifyMeld(cards){
  if(cards.length===1 && cards[0].rank==='7') return { kind:'seven', cards:[...cards] };
  if(isSet(cards)) return { kind:'set', cards: sortByRank(cards) };
  if(isRun(cards)) return { kind:'run', cards: sortByRank(cards) };
  return null;
}
function canAttach(card, meld){
  if(meld.kind==='seven') return false;
  if(meld.kind==='set'){
    return isSet([...meld.cards, card]);
  }
  if(meld.kind==='run'){
    return canAttachRunEnds(card, meld.cards);
  }
  return false;
}
function canAttachRunEnds(card, runCards){
  if(runCards.length<3) return false;
  const suit=runCards[0].suit; if(!runCards.every(c=>c.suit===suit)) return false;
  if(card.suit!==suit) return false;
  const low = [...runCards].map(c=>rankValue(c.rank)).sort((a,b)=>a-b);
  const high = [...runCards].map(c=>c.rank==='A'?14:rankValue(c.rank)).sort((a,b)=>a-b);
  const isSeq = arr => arr.every((v,i)=> i===0 || v===arr[i-1]+1);
  let allow=false;
  const vL = rankValue(card.rank), vH = (card.rank==='A'?14:rankValue(card.rank));
  if(isSeq(low)){ if(vL===low[0]-1 || vL===low[low.length-1]+1) allow=true; }
  if(!allow && isSeq(high)){ if(vH===high[0]-1 || vH===high[high.length-1]+1) allow=true; }
  return allow && isRun([...runCards, card]);
}

/* ========= State ========= */
const state = {
  deck: [], discard: [], melds: [],
  players: [], // {id,name,isBot,hand,status}
  turnIndex: 0,
  phase: 'choose-source', // choose-source | action | gameover
  finishOrder: [],
  options: { continueAfterOut: true },
  round: 1,
  mustUseThankYouCardId: null,
  ty: { open:false, claimant:null, fromPlayerId:null, cardId:null }, // 땡큐 선착순 창
};

function initPlayers(count=3){
  state.players = [];
  // P1 = You
  state.players.push({ id:'P1', name:'You', isBot:false, hand:[], status:'active' });
  const need = Math.max(0, count-1);
  const names = ['Bot α','Bot β','Bot γ','Bot δ','Bot ε'];
  for(let i=0;i<need;i++){
    state.players.push({ id:'P'+(i+2), name:names[i%names.length], isBot:true, hand:[], status:'active' });
  }
  // 최소 3명 보장
  while(state.players.length<3){
    state.players.push({ id:'P'+(state.players.length+1), name:names[(state.players.length-1)%names.length], isBot:true, hand:[], status:'active' });
  }
}

function newGame(playerCount=3){
  state.deck = buildDeck();
  state.discard = [];
  state.melds = [];
  initPlayers(playerCount);
  state.turnIndex = 0; state.phase='choose-source'; state.finishOrder=[]; state.round=1; state.mustUseThankYouCardId=null; state.ty={open:false, claimant:null, fromPlayerId:null, cardId:null};
  for(let i=0;i<7;i++) state.players.forEach(p=>p.hand.push(state.deck.pop()));
  state.discard.push(state.deck.pop());
  drawUI(); logMsg('게임 시작!');
  maybeBotTurn();
}
function current(){ return state.players[state.turnIndex]; }
function nextActiveIndex(from){ const n=state.players.length; for(let k=1;k<=n;k++){ const idx=(from+k)%n; if(state.players[idx].status==='active') return idx; } return from; }

/* ========= Rule helpers ========= */
function kComb(arr, minK=3, maxK=5){
  const res=[]; const n=arr.length; const max=Math.min(maxK,n);
  function rec(start, combo){
    if(combo.length>=minK) res.push([...combo]);
    if(combo.length===max) return;
    for(let i=start;i<n;i++){ combo.push(arr[i]); rec(i+1, combo); combo.pop(); }
  }
  rec(0,[]); return res;
}
function legalThankYouFor(player){
  const top = state.discard[state.discard.length-1]; if(!top) return {allowed:false};
  if(!state.ty.open) return {allowed:false};
  if(state.ty.fromPlayerId===player.id) return {allowed:false}; // 자기 버림은 못먹음
  // 붙이기 가능?
  for(let i=0;i<state.melds.length;i++){ if(canAttach(top, state.melds[i])) return {allowed:true, card:top, mode:'attach'}; }
  // 등록 가능? (7 단독 포함)
  const trial = [...player.hand, top];
  const combos = kComb(trial, 1, 5);
  for(const c of combos){ const m=classifyMeld(c); if(m && c.some(x=>x.id===top.id)) return {allowed:true, card:top, mode:'register'}; }
  return {allowed:false};
}
function afterAnyAction(player){
  if(player.status==='active' && player.hand.length===0){
    player.status='out'; state.finishOrder.push(player.id);
    toast(`${player.name} 아웃!`);
    state.mustUseThankYouCardId=null; state.ty={open:false, claimant:null, fromPlayerId:null, cardId:null};
    if(!state.options.continueAfterOut){ state.phase='gameover'; drawUI(); return true; }
    const left = state.players.filter(p=>p.status==='active').length;
    if(left<=1){
      const last = state.players.find(p=>p.status==='active');
      if(last){ last.status='out'; state.finishOrder.push(last.id); }
      state.phase='gameover'; drawUI(); return true;
    }
    if(current().id===player.id){ state.turnIndex = nextActiveIndex(state.turnIndex); state.phase='choose-source'; }
  }
  return false;
}
function endTurn(){
  state.turnIndex = nextActiveIndex(state.turnIndex);
  state.phase='choose-source';
  state.mustUseThankYouCardId=null;
  state.ty={open:false, claimant:null, fromPlayerId:null, cardId:null};
}

/* ========= Actions ========= */
function reshuffleFromDiscard(){
  if(state.discard.length<2) return; // keep top
  const top = state.discard.pop();
  state.deck = shuffle(state.discard); state.discard=[top];
  toast('버린 패를 섞어 덱 보충');
}

function drawFromDeck(){
  const p=current(); if(state.phase!=='choose-source') return;
  if(state.deck.length===0){ reshuffleFromDiscard(); }
  if(state.deck.length===0) { logMsg('덱 고갈!'); return; }
  const fromRect = document.getElementById('deckZone').getBoundingClientRect();
  const newCard = state.deck.pop();
  p.hand.push(newCard);
  state.phase='action';
  state.ty.open=false; // 드로우 택했으므로
  drawUI();
  const targetEl = document.querySelector(`#hand .card[data-id="${newCard.id}"]`);
  if(targetEl){ const toRect = targetEl.getBoundingClientRect(); flyCard(fromRect, toRect, newCard); }
}

function claimThankYou(playerIndex){
  const player = state.players[playerIndex];
  const chk = legalThankYouFor(player); if(!chk.allowed) return false;
  if(!state.ty.open) return false;
  if(state.ty.claimant && state.ty.claimant!==player.id) return false;
  state.ty.claimant = player.id;
  const topEl = document.querySelector('#discardCards .card');
  const fromRect = topEl? topEl.getBoundingClientRect() : document.getElementById('discardZone').getBoundingClientRect();
  const top=state.discard.pop(); player.hand.push(top);
  state.mustUseThankYouCardId = top.id;
  state.phase = (playerIndex===state.turnIndex) ? 'action' : state.phase;
  toast(`땡큐! ${player.name} 선점 ✅`);
  drawUI();
  const targetEl = document.querySelector(`#hand .card[data-id="${top.id}"]`);
  if(targetEl){ const toRect = targetEl.getBoundingClientRect(); flyCard(fromRect, toRect, top); }
  state.ty.open=false;
  return true;
}
function takeThankYou(){ claimThankYou(0); }

function registerSelected(kind){
  const p=current(); if(state.phase==='choose-source'){ toast('먼저 드로우 또는 땡큐'); return; }
  const sel = selectedFromHand(); if(sel.length<1){ toast('카드를 선택하세요'); return; }
  if(state.mustUseThankYouCardId && !sel.some(c=>c.id===state.mustUseThankYouCardId)){
    toast('땡큐 카드부터 사용해야 해요'); return;
  }
  const m = classifyMeld(sel);
  if(!m){ toast('유효하지 않은 조합'); return; }
  if(kind==='set' && m.kind!=='set') { toast('세트 아님'); return; }
  if(kind==='run' && m.kind!=='run') { toast('런 아님'); return; }
  if(m.kind==='seven' || kind===undefined || kind===m.kind){
    p.hand = p.hand.filter(c=>!sel.includes(c));
    state.melds.push(m);
    logMsg(`${p.name} 등록: ${m.kind.toUpperCase()} (${pretty(m.cards)})`);
    if(state.mustUseThankYouCardId && sel.some(c=>c.id===state.mustUseThankYouCardId)) state.mustUseThankYouCardId=null;
    clearSelection(); drawUI(); if(afterAnyAction(p)) return; return;
  }
  toast('요청한 종류와 일치하지 않음');
}

function attachSelected(){
  const p=current(); if(state.phase==='choose-source'){ toast('먼저 드로우 또는 땡큐'); return; }
  const sel = selectedFromHand(); if(sel.length!==1){ toast('붙이기는 1장만 선택'); return; }
  const card=sel[0];
  if(state.mustUseThankYouCardId && card.id!==state.mustUseThankYouCardId){ toast('땡큐 카드부터 사용'); return; }
  for(let i=0;i<state.melds.length;i++){
    const m=state.melds[i]; if(canAttach(card,m)){
      p.hand = p.hand.filter(c=>c!==card); m.cards.push(card); m.cards = sortByRank(m.cards);
      logMsg(`${p.name} 붙이기: ${card.rank}${card.suit} → #${i+1}`);
      if(state.mustUseThankYouCardId===card.id) state.mustUseThankYouCardId=null;
      drawUI(); afterAnyAction(p); return;
    }
  }
  toast('붙일 수 있는 곳이 없어요');
}

let pendingDiscard=null;
function setDiscard(){
  const p=current(); if(state.phase==='choose-source'){ toast('먼저 드로우 또는 땡큐'); return; }
  if(state.mustUseThankYouCardId){ toast('땡큐 카드 먼저 사용해야 버림 가능'); return; }
  const sel = selectedFromHand(); if(sel.length!==1){ toast('버리기는 1장 선택'); return; }
  pendingDiscard = sel[0];
  document.getElementById('btnDiscard').disabled=false;
  drawUI();
}
function commitDiscard(){
  const p=current();
  if(state.mustUseThankYouCardId){ toast('땡큐 카드 먼저 사용!'); return; }
  if(!pendingDiscard){ const sel=selectedFromHand(); if(sel.length===1) pendingDiscard=sel[0]; }
  if(!pendingDiscard){ toast('버릴 카드를 1장 선택'); return; }
  const fromEl = document.querySelector(`#hand .card[data-id="${pendingDiscard.id}"]`);
  const fromRect = fromEl? fromEl.getBoundingClientRect() : document.getElementById('hand').getBoundingClientRect();
  p.hand = p.hand.filter(c=>c!==pendingDiscard);
  state.discard.push(pendingDiscard); logMsg(`${p.name} 버림: ${cardText(pendingDiscard)}`);
  const just = pendingDiscard;
  pendingDiscard=null; document.getElementById('btnDiscard').disabled=true; clearSelection();
  // 땡큐 선착순 창 오픈
  state.ty = { open:true, claimant:null, fromPlayerId:p.id, cardId:just.id };
  drawUI();
  const topEl = document.querySelector('#discardCards .card');
  if(topEl){ const toRect = topEl.getBoundingClientRect(); flyCard(fromRect, toRect, just); }
  // 봇이 바로 선점 가능하면 시도
  const nextIdx = nextActiveIndex(state.turnIndex);
  const bot = state.players[nextIdx];
  if(bot?.isBot){
    const chk = legalThankYouFor(bot);
    if(chk.allowed){
      claimThankYou(nextIdx);
      // 즉시사용 시도: 등록 우선 → 붙이기
      const combos = kComb(bot.hand,1,5).sort((a,b)=>b.length-a.length);
      for(const cs of combos){ const m=classifyMeld(cs); if(m && cs.some(c=>c.id===state.mustUseThankYouCardId)){ bot.hand = bot.hand.filter(c=>!cs.includes(c)); state.melds.push(m); logMsg(`Bot(땡큐) 등록: ${m.kind.toUpperCase()}`); state.mustUseThankYouCardId=null; break; } }
      if(state.mustUseThankYouCardId){
        for(let j=0;j<state.melds.length;j++){ const top = bot.hand.find(c=>c.id===state.mustUseThankYouCardId); if(top && canAttach(top,state.melds[j])){ bot.hand = bot.hand.filter(x=>x!==top); state.melds[j].cards.push(top); state.melds[j].cards=sortByRank(state.melds[j].cards); logMsg('Bot(땡큐) 붙이기'); state.mustUseThankYouCardId=null; break; } }
      }
    }
  }
  if(afterAnyAction(p)) return;
  endTurn(); drawUI(); maybeBotTurn();
}

/* ========= Bot ========= */
function maybeBotTurn(){
  const p=current(); if(!p.isBot || state.phase==='gameover') return;
  const delay = (ms)=>new Promise(res=>setTimeout(res, ms));
  (async()=>{ await delay(300 + Math.random()*500); await botActAsync(delay); })();
}
async function botActAsync(delay){
  const p=current(); if(!p.isBot || p.status!=='active') return;
  if(state.phase==='choose-source'){
    await delay(200+Math.random()*400);
    if(state.ty.open && !state.ty.claimant){
      const chk = legalThankYouFor(p);
      if(chk.allowed){ claimThankYou(state.turnIndex); drawUI(); return botActAsync(delay); }
    }
    drawFromDeck(); drawUI(); return botActAsync(delay);
  }
  const tryRegister = async () => {
    const combos = kComb(p.hand,1,5).sort((a,b)=>b.length-a.length);
    for(const cs of combos){ const m=classifyMeld(cs); if(m){
      await delay(180+Math.random()*300);
      p.hand = p.hand.filter(c=>!cs.includes(c)); state.melds.push(m);
      logMsg(`Bot 등록: ${m.kind.toUpperCase()} (${pretty(m.cards)})`);
      drawUI(); if(afterAnyAction(p)) return true; return tryRegister();
    }} return false;
  };
  if(await tryRegister()) return;
  for(let i=0;i<p.hand.length;i++){
    const c=p.hand[i];
    for(let j=0;j<state.melds.length;j++){
      if(canAttach(c,state.melds[j])){
        await delay(160+Math.random()*280);
        p.hand.splice(i,1); state.melds[j].cards.push(c); state.melds[j].cards=sortByRank(state.melds[j].cards);
        logMsg(`Bot 붙이기: ${cardText(c)} → #${j+1}`);
        drawUI(); if(afterAnyAction(p)) return; i=-1; break;
      }
    }
  }
  await delay(200+Math.random()*320);
  let candIndex=0, bestScore=-1;
  for(let i=0;i<p.hand.length;i++){
    const c=p.hand[i];
    const rv=rankValue(c.rank); const suitScore = p.hand.filter(x=>x.suit===c.suit).length;
    const rankScore = p.hand.filter(x=>x.rank===c.rank).length;
    const score = rv + (1/(suitScore||1))*4 + (1/(rankScore||1))*6;
    if(score>bestScore){bestScore=score; candIndex=i;}
  }
  const dc = p.hand.splice(candIndex,1)[0]; state.discard.push(dc); logMsg(`Bot 버림: ${cardText(dc)}`);
  state.ty = { open:true, claimant:null, fromPlayerId:p.id, cardId:dc.id };
  drawUI(); if(afterAnyAction(p)) return; endTurn(); drawUI();
}

/* ========= UI ========= */
function drawUI(){
  document.getElementById('opt-continue').checked = state.options.continueAfterOut;
  document.getElementById('turnBadge').textContent = `턴: ${current().name}`;
  document.getElementById('roundInfo').textContent = `R${state.round}${state.phase==='gameover'?' · 게임끝':''}`;

  const deckCount = document.getElementById('deckCount'); deckCount.textContent = `남은 장수: ${state.deck.length}`;

  const dc = document.getElementById('discardCards'); dc.innerHTML='';
  const top = state.discard[state.discard.length-1]; if(top) { const el=cardNode(top,false); el.classList.add('enter'); dc.appendChild(el); }

  const mwrap = document.getElementById('melds'); mwrap.innerHTML='';
  state.melds.forEach((m,i)=>{
    const d=document.createElement('div'); d.className='meld enter';
    const title=document.createElement('div'); title.style.fontSize='12px'; title.style.color='#334';
    title.textContent = `#${i+1} · ${m.kind.toUpperCase()} (${m.cards.length})`;
    const row=document.createElement('div'); row.className='cards';
    m.cards.forEach(c=>{ const el=cardNode(c,false); el.classList.add('enter'); row.appendChild(el); });
    d.appendChild(title); d.appendChild(row); mwrap.appendChild(d);
  });

  const h = document.getElementById('hand'); h.innerHTML='';
  const me = state.players[0];
  me.hand.forEach(c=> { const el=cardNode(c,true); el.draggable=true; el.addEventListener('dragstart', dragStart); el.addEventListener('dragover', dragOver); el.addEventListener('drop', dropSwap); el.classList.add('enter'); h.appendChild(el); });

  const plist=document.getElementById('players'); plist.innerHTML='';
  state.players.forEach((p)=>{
    const d=document.createElement('div'); d.className='seat';
    const nm=document.createElement('div'); nm.className='name'; nm.textContent=p.name+(p.isBot?' 🤖':' 🙂');
    const st=document.createElement('div'); st.innerHTML = `<span class="pill">${p.status==='active'?`hand ${p.hand.length}`:'OUT'}</span>`;
    d.appendChild(nm); d.appendChild(st); plist.appendChild(d);
  });

  const f=document.getElementById('finish'); f.innerHTML='';
  state.finishOrder.forEach((pid,idx)=>{ const li=document.createElement('li'); const nm = state.players.find(p=>p.id===pid)?.name||pid; li.textContent = `${idx+1}등 · ${nm}`; f.appendChild(li); });

  const meTurn = current().id==='P1' && state.players[0].status==='active' && state.phase!=='gameover';
  document.getElementById('btnDraw').disabled = !meTurn || state.phase!=='choose-source';
  const tyCheck = legalThankYouFor(state.players[0]);
  const tyBtn=document.getElementById('btnTY');
  tyBtn.disabled = !(state.ty.open && (!state.ty.claimant || state.ty.claimant==='P1') && tyCheck.allowed);
}

function cardNode(card, selectable){
  const d=document.createElement('div'); d.className='card'; d.dataset.id=card.id;
  const r=document.createElement('div'); r.className='rank ' + (isRed(card.suit)?'red':'black'); r.textContent=card.rank;
  const s=document.createElement('div'); s.className='suit ' + (isRed(card.suit)?'red':'black'); s.textContent=card.suit;
  d.appendChild(r); d.appendChild(s);
  if(selectable){ d.addEventListener('click',()=>toggleSelect(card.id,d)); }
  return d;
}
const selected = new Set();
function toggleSelect(id, el){ if(selected.has(id)){ selected.delete(id); el.classList.remove('selected'); } else { selected.add(id); el.classList.add('selected'); } updateDiscardButtonState(); }
function selectedFromHand(){ const me=state.players[0]; const ids=[...selected]; const out=[]; ids.forEach(id=>{ const c=me.hand.find(x=>x.id===id); if(c) out.push(c); }); return out; }
function clearSelection(){ selected.clear(); updateDiscardButtonState(); }
function updateDiscardButtonState(){ const btn = document.getElementById('btnDiscard'); const meTurn = current().id==='P1' && state.players[0].status==='active' && state.phase!=='gameover'; const one = selectedFromHand().length===1; btn.disabled = !(meTurn && state.phase!=='choose-source' && one && !state.mustUseThankYouCardId); }

/* drag reorder */
let dragId=null;
function dragStart(e){ dragId = e.currentTarget.dataset.id; e.dataTransfer.setData('text/plain', dragId); }
function dragOver(e){ e.preventDefault(); }
function dropSwap(e){
  e.preventDefault(); const targetId = e.currentTarget.dataset.id; if(!dragId || dragId===targetId) return;
  const hand = state.players[0].hand;
  const a = hand.findIndex(c=>c.id===dragId); const b = hand.findIndex(c=>c.id===targetId);
  [hand[a],hand[b]]=[hand[b],hand[a]]; dragId=null; drawUI();
}

/* ========= UX helpers ========= */
function flyCard(fromRect, toRect, card){
  const f=document.createElement('div'); f.className='flycard';
  const r=document.createElement('div'); r.className='flyrank'; r.textContent=card.rank; r.style.color=(isRed(card.suit)?'#e34d5c':'#2b2f3a');
  const s=document.createElement('div'); s.className='flysuit'; s.textContent=card.suit; s.style.color=(isRed(card.suit)?'#e34d5c':'#2b2f3a');
  f.appendChild(r); f.appendChild(s); document.body.appendChild(f);
  const startX = fromRect.left + (fromRect.width/2) - 35; const startY = fromRect.top + (fromRect.height/2) - 49;
  f.style.transform = `translate(${startX}px, ${startY}px)`; f.style.opacity = .7; f.getBoundingClientRect();
  const endX = toRect.left + (toRect.width/2) - 35; const endY = toRect.top + (toRect.height/2) - 49;
  requestAnimationFrame(()=>{ f.style.transform = `translate(${endX}px, ${endY}px)`; f.style.opacity=1; });
  setTimeout(()=>{ f.remove(); }, 300);
}
function toast(message, ms=1200){
  const t = document.getElementById('toast'); if(!t) return;
  t.textContent = message; t.style.display='block';
  clearTimeout(window.__toastTimer); window.__toastTimer = setTimeout(()=>{ t.style.display='none'; }, ms);
}
function logMsg(msg){ const l=document.getElementById('log'); if(!l){ console.log('[LOG]', msg); return; } const line=document.createElement('div'); line.textContent=msg; l.appendChild(line); l.scrollTop=l.scrollHeight; }
function cardText(c){ return `${c.rank}${c.suit}`; }
function pretty(cards){ return cards.map(cardText).join(' '); }

/* ========= Networking (WebRTC) ========= */
const net = { role:null, pc:null, dc:null, online:false, isHost:false };
const ICE = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };
const netBadge = ()=>document.getElementById('netBadge');

async function hostStart(){
  net.role='host'; net.isHost=true; net.pc=new RTCPeerConnection(ICE);
  net.dc = net.pc.createDataChannel('hoola'); wireDataChannel(net.dc);
  const offer = await net.pc.createOffer(); await net.pc.setLocalDescription(offer);
  document.getElementById('sdpOut').value = btoa(JSON.stringify(net.pc.localDescription));
  net.pc.onicecandidate = (e)=>{ if(!e.candidate){ document.getElementById('sdpOut').value = btoa(JSON.stringify(net.pc.localDescription)); }};
}
async function guestStart(){
  net.role='guest'; net.isHost=false; net.pc=new RTCPeerConnection(ICE);
  net.pc.ondatachannel = (e)=>{ net.dc=e.channel; wireDataChannel(net.dc); };
  const offerStr = document.getElementById('sdpIn').value.trim(); if(!offerStr) return toast('호스트 코드를 붙여넣으세요');
  const offer = JSON.parse(atob(offerStr));
  await net.pc.setRemoteDescription(offer);
  const answer = await net.pc.createAnswer(); await net.pc.setLocalDescription(answer);
  document.getElementById('sdpOut').value = btoa(JSON.stringify(net.pc.localDescription));
  net.pc.onicecandidate = (e)=>{ if(!e.candidate){ document.getElementById('sdpOut').value = btoa(JSON.stringify(net.pc.localDescription)); }};
}
async function hostApplyAnswer(){
  const ansStr = document.getElementById('sdpIn').value.trim(); if(!ansStr) return toast('게스트 코드를 붙여넣으세요');
  const ans = JSON.parse(atob(ansStr)); await net.pc.setRemoteDescription(ans);
}
function wireDataChannel(dc){
  dc.onopen=()=>{ net.online=true; netBadge().textContent='온라인'; netBadge().style.background='rgba(80,200,120,.2)';
    // 2인 실시간: Host는 P1/Guest는 P2로 매핑. (최소 3인 규칙은 Host가 Bot으로 충원)
    if(net.isHost){ newGame(3); sendSnapshot(); }
  };
  dc.onmessage=(e)=>{
    const msg = JSON.parse(e.data);
    if(msg.t==='snapshot'){ Object.assign(state, msg.state); drawUI(); return; }
    if(!net.isHost){ return; } // 권위적 호스트
    handleRemoteAction(msg);
  };
}
function sendSnapshot(){ if(net.online && net.dc?.readyState==='open'){ net.dc.send(JSON.stringify({t:'snapshot', state})); }}
function sendAction(a){ if(net.online && net.dc?.readyState==='open'){ net.dc.send(JSON.stringify(a)); }}

function handleRemoteAction(a){
  // 호스트가 선착순 및 검증 수행
  switch(a.t){
    case 'draw': if(current().id==='P2') { drawFromDeck(); drawUI(); } break;
    case 'thankyou': { // 선착순
      if(state.ty.open && !state.ty.claimant){
        const idx = state.players.findIndex(p=>p.id==='P2'); claimThankYou(idx); drawUI();
      }
    } break;
    case 'register': {
      if(current().id!=='P2' || state.phase==='gameover') break;
      const p = state.players[1];
      const cards = p.hand.filter(c=>a.ids.includes(c.id));
      if(state.mustUseThankYouCardId && !cards.some(c=>c.id===state.mustUseThankYouCardId)) break;
      const m = classifyMeld(cards);
      if(!m) break; if(a.kind && m.kind!==a.kind) break;
      p.hand = p.hand.filter(c=>!cards.includes(c)); state.melds.push(m); logMsg(`Remote 등록: ${m.kind}`);
      if(state.mustUseThankYouCardId && cards.some(c=>c.id===state.mustUseThankYouCardId)) state.mustUseThankYouCardId=null;
      afterAnyAction(p);
    } break;
    case 'attach': {
      if(current().id!=='P2' || state.phase==='gameover') break;
      const p=state.players[1]; const card=p.hand.find(c=>c.id===a.id); if(!card) break;
      if(state.mustUseThankYouCardId && card.id!==state.mustUseThankYouCardId) break;
      let targetIndex = -1; for(let j=0;j<state.melds.length;j++){ if(canAttach(card, state.melds[j])) { targetIndex=j; break; } }
      if(targetIndex>=0){
        const m=state.melds[targetIndex]; p.hand=p.hand.filter(x=>x!==card); m.cards.push(card); m.cards=sortByRank(m.cards); logMsg('Remote 붙이기');
        if(state.mustUseThankYouCardId===card.id) state.mustUseThankYouCardId=null; afterAnyAction(p);
      }
    } break;
    case 'discard': {
      if(current().id!=='P2' || state.phase==='gameover') break;
      if(state.mustUseThankYouCardId) break;
      const p=state.players[1]; const card=p.hand.find(c=>c.id===a.id); if(!card) break; p.hand=p.hand.filter(x=>x!==card); state.discard.push(card);
      state.ty = { open:true, claimant:null, fromPlayerId:p.id, cardId:card.id };
      endTurn();
    } break;
  }
  drawUI(); sendSnapshot();
}

/* ========= Events ========= */
const elDraw=document.getElementById('btnDraw');
const elTY=document.getElementById('btnTY');
const elRegSet=document.getElementById('btnRegSet');
const elRegRun=document.getElementById('btnRegRun');
const elAttach=document.getElementById('btnAttach');
const elPendDiscard=document.getElementById('btnDiscard');
const elReset=document.getElementById('btnReset');

elDraw.onclick=()=>{ if(net.online && !net.isHost && current().id==='P2') sendAction({t:'draw'}); else { drawFromDeck(); sendSnapshot(); } };
elTY.onclick=()=>{ if(net.online && !net.isHost) sendAction({t:'thankyou'}); else { takeThankYou(); sendSnapshot(); } };
elRegSet.onclick=()=>{ const ids = selectedFromHand().map(c=>c.id); if(net.online && !net.isHost && current().id==='P2') sendAction({t:'register', kind:'set', ids}); else { registerSelected('set'); sendSnapshot(); } };
elRegRun.onclick=()=>{ const ids = selectedFromHand().map(c=>c.id); if(net.online && !net.isHost && current().id==='P2') sendAction({t:'register', kind:'run', ids}); else { registerSelected('run'); sendSnapshot(); } };
elAttach.onclick=()=>{ const sel = selectedFromHand(); if(sel.length!==1){ attachSelected(); sendSnapshot(); return; } const id = sel[0].id; if(net.online && !net.isHost && current().id==='P2') sendAction({t:'attach', id}); else { attachSelected(); sendSnapshot(); } };

document.getElementById('hand').addEventListener('dblclick', ()=>{ setDiscard(); });
elPendDiscard.onclick=()=>{ if(net.online && !net.isHost && current().id==='P2'){ const sel = selectedFromHand(); if(sel.length===1) sendAction({t:'discard', id: sel[0].id}); } else { commitDiscard(); sendSnapshot(); } };

document.getElementById('opt-continue').addEventListener('change', (e)=>{ state.options.continueAfterOut = e.target.checked; sendSnapshot(); });

elReset.onclick=()=>{ newGame(3); sendSnapshot(); };

document.getElementById('btnHost').onclick=()=>hostStart();
document.getElementById('btnJoin').onclick=()=>guestStart();
document.getElementById('btnApply').onclick=()=>hostApplyAnswer();

/* ========= Unit Tests ========= */
(function runUnitTests(){
  const results=[]; const rec=(name,ok,detail='')=>{ results.push({name,ok,detail}); (ok?console.log:console.error)(ok?`PASS: ${name}`:`FAIL: ${name} — ${detail}`); };
  try{ rec('isSet valid 5x3', isSet([{rank:'5',suit:'♣'},{rank:'5',suit:'♥'},{rank:'5',suit:'♦'}])); }catch(e){ rec('isSet valid 5x3', false, e.message); }
  try{ rec('isSet invalid len<3', !isSet([{rank:'5',suit:'♣'},{rank:'5',suit:'♥'}])); }catch(e){ rec('isSet invalid len<3', false, e.message); }
  try{ rec('isRun 5-6-7 ♥', isRun([{rank:'5',suit:'♥'},{rank:'6',suit:'♥'},{rank:'7',suit:'♥'}])); }catch(e){ rec('isRun 5-6-7 ♥', false, e.message); }
  try{ rec('isRun A-2-3 ♣ (low ace)', isRun([{rank:'A',suit:'♣'},{rank:'2',suit:'♣'},{rank:'3',suit:'♣'}])); }catch(e){ rec('isRun A-2-3 low', false, e.message); }
  try{ rec('isRun Q-K-A ♦ (high ace)', isRun([{rank:'Q',suit:'♦'},{rank:'K',suit:'♦'},{rank:'A',suit:'♦'}])); }catch(e){ rec('isRun Q-K-A high', false, e.message); }
  try{ rec('isRun no wrap K-A-2 ♠', !isRun([{rank:'K',suit:'♠'},{rank:'A',suit:'♠'},{rank:'2',suit:'♠'}])); }catch(e){ rec('isRun no wrap', false, e.message); }
  try{ const m = classifyMeld([{rank:'7',suit:'♣'}]); rec('classify single 7 → seven', m && m.kind==='seven'); }catch(e){ rec('classify seven', false, e.message); }
  try{ const setM = {kind:'set', cards:[{rank:'5',suit:'♥'},{rank:'5',suit:'♦'},{rank:'5',suit:'♠'}]}; rec('attach 5♣ to set', canAttach({rank:'5',suit:'♣'}, setM)); }catch(e){ rec('attach to set', false, e.message); }
  try{ const runM = {kind:'run', cards: sortByRank([{rank:'2',suit:'♥'},{rank:'3',suit:'♥'},{rank:'4',suit:'♥'}])}; rec('attach 5♥ to run end', canAttach({rank:'5',suit:'♥'}, runM)); }catch(e){ rec('attach to run end 5', false, e.message); }
  try{ const runM2 = {kind:'run', cards: sortByRank([{rank:'3',suit:'♥'},{rank:'4',suit:'♥'},{rank:'5',suit:'♥'}])}; rec('attach 2♥ to run start', canAttach({rank:'2',suit:'♥'}, runM2)); }catch(e){ rec('attach to run start 2', false, e.message); }
  try{ const runM3 = {kind:'run', cards: sortByRank([{rank:'3',suit:'♥'},{rank:'4',suit:'♥'},{rank:'5',suit:'♥'}])}; rec('attach 6♥ to run end', canAttach({rank:'6',suit:'♥'}, runM3)); }catch(e){ rec('attach to run end 6', false, e.message); }
  try{ const runM4 = {kind:'run', cards: sortByRank([{rank:'3',suit:'♥'},{rank:'4',suit:'♥'},{rank:'5',suit:'♥'}])}; rec('attach 4♥ (middle) not allowed', !canAttach({rank:'4',suit:'♥'}, runM4)); }catch(e){ rec('attach to run middle 4', false, e.message); }
  try{ const tmp=JSON.parse(JSON.stringify(state));
    state.players=[{id:'P1',name:'A',isBot:false,hand:[],status:'active'},{id:'P2',name:'B',isBot:false,hand:[],status:'active'}];
    state.discard=[{id:'X',rank:'7',suit:'♣'}]; state.melds=[]; state.phase='choose-source';
    state.ty={open:true, claimant:null, fromPlayerId:'P2', cardId:'X'};
    const preLen = state.players[0].hand.length; const c1 = claimThankYou(0); const c2 = claimThankYou(1);
    rec('thankyou first-come wins', c1===true && c2===false && state.players[0].hand.length===preLen+1);
    Object.assign(state,tmp);
  }catch(e){ rec('thankyou race', false, e.message); }
  try{ const tmp=JSON.parse(JSON.stringify(state)); state.deck=[]; state.discard=[{id:'a',rank:'2',suit:'♣'},{id:'b',rank:'9',suit:'♦'},{id:'T',rank:'Q',suit:'♠'}]; const beforeTop=state.discard[state.discard.length-1]; reshuffleFromDiscard(); const afterTop=state.discard[state.discard.length-1]; rec('reshuffle keeps top', beforeTop.id===afterTop.id); rec('reshuffle refills deck', state.deck.length>0); Object.assign(state,tmp);}catch(e){ rec('reshuffle behavior', false, e.message); }
  const ok = results.filter(r=>r.ok).length; const total = results.length; logMsg(`테스트: ${ok}/${total} 성공`);
})();

/* ========= Boot ========= */
newGame(3);
</script>
</body>
</html>
