<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Hoola (훌라) — 네온 3D 아레나</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: #040b16;
      --bg-alt: radial-gradient(circle at 20% -10%, rgba(110, 80, 255, 0.25), transparent 60%),
                radial-gradient(circle at 110% 0%, rgba(255, 112, 188, 0.2), transparent 55%),
                #050915;
      --ink: #f6f9ff;
      --muted: rgba(240, 246, 255, 0.65);
      --primary: #5df1ff;
      --accent: #ff86d5;
      --ok: #6fffb4;
      --warn: #ffc66b;
      --danger: #ff6b9a;
      --panel: rgba(5, 18, 38, 0.78);
      --panel-border: rgba(93, 241, 255, 0.22);
      --card: rgba(6, 14, 28, 0.95);
      --card-border: rgba(131, 214, 255, 0.4);
      --shadow: 0 24px 60px rgba(3, 8, 20, 0.7);
      --radius: 22px;
      font-family: "Pretendard", "Apple SD Gothic Neo", "Segoe UI", system-ui, sans-serif;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
    }

    body {
      margin: 0;
      background: var(--bg-alt);
      color: var(--ink);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: clamp(18px, 4vw, 36px);
    }

    .app {
      display: grid;
      grid-template-rows: auto 1fr auto;
      gap: clamp(12px, 2.4vw, 24px);
      width: min(1160px, 100%);
      min-height: min(100%, 760px);
    }

    header {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 18px;
    }

    header h1 {
      margin: 0;
      font-size: clamp(1.2rem, 2.6vw, 1.8rem);
      letter-spacing: 0.2em;
      text-transform: uppercase;
    }

    header .opts {
      display: flex;
      gap: 12px;
      align-items: center;
      color: var(--muted);
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    header .opts label,
    header .opts .seat-control {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      background: rgba(8, 20, 40, 0.72);
      padding: 6px 12px;
      border-radius: 999px;
      border: 1px solid rgba(93, 241, 255, 0.18);
    }

    header .opts .seat-control {
      color: var(--ink);
      font-weight: 600;
      letter-spacing: 0.02em;
    }

    header .opts .seat-control select {
      appearance: none;
      border: none;
      background: transparent;
      color: inherit;
      font: inherit;
      font-weight: 700;
      padding: 0 2px;
      cursor: pointer;
      min-width: 72px;
    }

    header .opts .seat-control select:disabled {
      cursor: not-allowed;
      opacity: 0.6;
    }

    header .opts input[type="checkbox"] {
      accent-color: var(--primary);
    }

    .board {
      display: grid;
      grid-template-columns: minmax(0, 1fr) 320px;
      gap: clamp(16px, 2.5vw, 28px);
      min-height: 0;
    }

    .table {
      position: relative;
      border-radius: 32px;
      padding: clamp(16px, 2.6vw, 28px);
      background: rgba(5, 14, 28, 0.82);
      border: 1px solid rgba(93, 241, 255, 0.16);
      box-shadow: 0 30px 80px rgba(5, 12, 32, 0.6);
      overflow: auto;
    }

    .table::before {
      content: "";
      position: absolute;
      inset: 24px;
      border-radius: 36px;
      background: radial-gradient(circle at 50% 35%, rgba(93, 241, 255, 0.18), transparent 60%),
                  linear-gradient(160deg, rgba(22, 52, 104, 0.65), rgba(7, 10, 20, 0.85));
      transform: rotateX(18deg) rotateZ(-4deg);
      transform-origin: center top;
      filter: drop-shadow(0 28px 60px rgba(14, 214, 255, 0.26));
      pointer-events: none;
      z-index: 0;
    }

    .table > * {
      position: relative;
      z-index: 1;
    }

    .zones {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: clamp(12px, 2.2vw, 20px);
    }

    .zone,
    .panel {
      background: var(--panel);
      border-radius: var(--radius);
      border: 1px solid var(--panel-border);
      box-shadow: var(--shadow);
      padding: clamp(12px, 1.8vw, 18px);
      display: flex;
      flex-direction: column;
      gap: 10px;
      backdrop-filter: blur(14px);
    }

    .zone h3,
    .panel h3 {
      margin: 0;
      font-size: 0.78rem;
      letter-spacing: 0.4em;
      text-transform: uppercase;
      color: var(--muted);
    }

    .panel strong {
      font-size: 0.95rem;
    }

    .right {
      display: flex;
      flex-direction: column;
      gap: clamp(12px, 2vw, 18px);
      min-height: 0;
    }

    /* card visuals */
    .cards {
      display: flex;
      align-items: flex-end;
      flex-wrap: wrap;
      gap: 10px;
    }

    .card {
      width: 70px;
      height: 98px;
      border-radius: 16px;
      background: var(--card);
      border: 1px solid var(--card-border);
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.06), 0 12px 30px rgba(9, 20, 40, 0.7);
      position: relative;
      transform: translateZ(0);
      transition: transform 0.25s ease, box-shadow 0.25s ease, opacity 0.25s ease;
      cursor: pointer;
      user-select: none;
    }

    .card:hover {
      transform: translateY(-6px) rotate(-1deg);
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.12), 0 26px 48px rgba(93, 241, 255, 0.25);
    }

    .card .inner {
      position: absolute;
      inset: 0;
      border-radius: inherit;
      display: grid;
      place-items: center;
      padding: 6px;
      background: radial-gradient(circle at 50% 20%, rgba(93, 241, 255, 0.15), transparent 60%);
    }

    .rank {
      font-weight: 900;
      font-size: 22px;
    }

    .suit {
      font-size: 18px;
    }

    .red {
      color: #ff7cbe;
    }

    .black {
      color: #e2ecff;
    }

    .selected {
      outline: 3px solid var(--primary);
      outline-offset: 2px;
      box-shadow: 0 0 22px rgba(93, 241, 255, 0.5);
    }

    .disabled {
      opacity: 0.4;
      pointer-events: none;
    }

    /* meld stack */
    .meld {
      padding: 12px;
      border-radius: 18px;
      background: rgba(8, 22, 48, 0.85);
      border: 1px solid rgba(93, 241, 255, 0.2);
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.04), 0 20px 40px rgba(5, 12, 30, 0.55);
      animation: pop 0.25s ease;
    }

    .meld .cards {
      gap: -46px;
    }

    .meld .card {
      transform: rotate(0);
    }

    .hand {
      position: sticky;
      bottom: 0;
      background: rgba(4, 12, 28, 0.9);
    }

    .hud {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    button {
      appearance: none;
      border: none;
      border-radius: 16px;
      padding: 10px 14px;
      font-weight: 700;
      letter-spacing: 0.04em;
      cursor: pointer;
      background: linear-gradient(135deg, #4c7cff, #5df1ff);
      color: #021024;
      box-shadow: 0 18px 40px rgba(12, 34, 72, 0.65);
      transition: transform 0.22s ease, box-shadow 0.22s ease, opacity 0.2s ease;
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 28px 60px rgba(93, 241, 255, 0.3);
    }

    button:active {
      transform: translateY(1px);
    }

    button.ghost {
      background: rgba(6, 18, 36, 0.92);
      color: var(--ink);
      border: 1px solid rgba(93, 241, 255, 0.3);
      box-shadow: 0 14px 32px rgba(4, 12, 28, 0.6);
    }

    button:disabled {
      opacity: 0.45;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      border-radius: 999px;
      background: rgba(8, 24, 46, 0.85);
      border: 1px solid rgba(93, 241, 255, 0.25);
      color: var(--muted);
    }

    .log {
      font-size: 12px;
      color: var(--muted);
      max-height: 160px;
      overflow: auto;
    }

    .player-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      padding: 8px 12px;
      border-radius: 14px;
      background: rgba(6, 18, 36, 0.7);
      border: 1px solid transparent;
      transition: border 0.2s ease, box-shadow 0.2s ease;
    }

    .player-row .name {
      display: flex;
      flex-direction: column;
      gap: 2px;
      font-weight: 600;
    }

    .player-row .name span {
      font-size: 11px;
      color: var(--muted);
      letter-spacing: 0.08em;
    }

    .player-row .meta {
      font-size: 12px;
      letter-spacing: 0.06em;
      text-transform: uppercase;
    }

    .player-row.active {
      border-color: rgba(93, 241, 255, 0.4);
      box-shadow: 0 0 22px rgba(93, 241, 255, 0.18);
    }

    .player-row.out {
      opacity: 0.45;
    }

    .rankpill {
      display: inline-block;
      background: rgba(93, 241, 255, 0.15);
      color: var(--primary);
      padding: 2px 8px;
      border-radius: 999px;
      font-weight: 700;
      letter-spacing: 0.04em;
    }

    .toast {
      position: fixed;
      right: clamp(12px, 2vw, 24px);
      bottom: clamp(12px, 2vw, 24px);
      background: rgba(0, 8, 18, 0.92);
      color: #fff;
      padding: 10px 14px;
      border-radius: 14px;
      border: 1px solid rgba(93, 241, 255, 0.25);
      opacity: 0.95;
      animation: slideup 0.25s ease;
      box-shadow: 0 24px 60px rgba(4, 12, 28, 0.65);
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      border-radius: 999px;
      background: rgba(93, 241, 255, 0.12);
      color: var(--primary);
      font-weight: 700;
      letter-spacing: 0.04em;
    }

    footer {
      display: flex;
      align-items: center;
      justify-content: space-between;
      color: var(--muted);
      gap: 12px;
    }

    footer button {
      margin-left: auto;
    }

    /* animations */
    @keyframes slideup {
      from {
        transform: translateY(12px);
        opacity: 0;
      }
      to {
        transform: translateY(0);
        opacity: 1;
      }
    }

    @keyframes pop {
      from {
        transform: scale(0.96);
      }
      to {
        transform: scale(1);
      }
    }

    @keyframes drop {
      from {
        transform: translateY(-10px);
        opacity: 0.6;
      }
      to {
        transform: translateY(0);
        opacity: 1;
      }
    }

    .enter {
      animation: drop 0.2s ease;
    }

    .pulse {
      animation: pulse-glow 1.1s ease-in-out infinite alternate;
    }

    @keyframes pulse-glow {
      from {
        box-shadow: 0 0 12px rgba(93, 241, 255, 0.22);
      }
      to {
        box-shadow: 0 0 26px rgba(93, 241, 255, 0.45);
      }
    }

    /* fly animations */
    .flycard {
      position: fixed;
      pointer-events: none;
      z-index: 9999;
      width: 70px;
      height: 98px;
      border-radius: 16px;
      background: rgba(6, 16, 32, 0.92);
      box-shadow: 0 18px 38px rgba(4, 10, 24, 0.7);
      display: grid;
      place-items: center;
      border: 1px solid rgba(93, 241, 255, 0.32);
      transition: transform 0.28s ease, opacity 0.28s ease;
    }

    .flyrank {
      font-weight: 900;
      font-size: 22px;
      color: #e2ecff;
    }

    .flysuit {
      font-size: 18px;
      color: #ff7cbe;
    }

    /* responsive */
    @media (max-width: 1100px) {
      .board {
        grid-template-columns: minmax(0, 1fr);
      }

      .right {
        order: -1;
        flex-direction: row;
        flex-wrap: wrap;
      }

      .right .panel {
        flex: 1 1 280px;
      }
    }

    @media (max-width: 720px) {
      body {
        padding: 18px;
      }

      header {
        flex-direction: column;
        align-items: stretch;
      }

      header .opts {
        flex-wrap: wrap;
        justify-content: flex-start;
      }

      .table {
        padding: 18px;
      }

      .table::before {
        inset: 18px;
        transform: none;
        filter: none;
      }

      .zones {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }

      .hand {
        position: static;
      }

      .cards {
        gap: 6px;
      }

      .card {
        width: 64px;
        height: 90px;
      }

      footer {
        flex-direction: column;
        align-items: flex-start;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>Hoola · 네온 3D</h1>
      <div class="opts">
        <label class="seat-control">좌석
          <select id="seatCount" aria-label="참가 인원 선택">
            <option value="3">3명</option>
            <option value="4">4명</option>
            <option value="5">5명</option>
            <option value="6">6명</option>
          </select>
        </label>
        <label><input type="checkbox" id="opt-continue" /> 아웃 후 계속(순위 확정)</label>
        <span class="badge" id="turnBadge">턴: -</span>
      </div>
    </header>

    <div class="board">
      <div class="table" id="table">
        <div class="zones">
          <div class="zone" id="deckZone">
            <h3>DECK</h3>
            <div class="cards" id="deckCount"></div>
            <div class="hud"><button id="btnDraw">드로우</button><button id="btnTY" class="ghost">땡큐</button></div>
          </div>
          <div class="zone" id="discardZone">
            <h3>DISCARD</h3>
            <div class="cards" id="discardCards"></div>
          </div>
          <div class="zone" id="infoZone">
            <h3>INFO</h3>
            <div class="log" id="log"></div>
          </div>
        </div>

        <div style="height:10px"></div>
        <div class="panel">
          <h3 style="margin:0 0 6px 0;color:var(--muted)">TABLE MELDS</h3>
          <div id="melds" style="display:grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap:12px"></div>
        </div>

        <div style="height:10px"></div>
        <div class="panel hand">
          <div style="display:flex; align-items:center; justify-content:space-between; gap:8px">
            <h3 style="margin:0;color:var(--muted)">YOUR HAND</h3>
            <div class="hud">
              <button id="btnRegSet" class="ghost">세트 등록</button>
              <button id="btnRegRun" class="ghost">런 등록</button>
              <button id="btnAttach" class="ghost">붙이기</button>
              <button id="btnDiscard" style="background:var(--danger)" disabled>버리고 종료</button>
            </div>
          </div>
          <div class="cards" id="hand"></div>
        </div>
      </div>

      <aside class="right">
        <div class="panel">
          <div style="display:flex; align-items:center; justify-content:space-between">
            <strong>Players</strong>
            <span class="pill" id="roundInfo">R1</span>
          </div>
          <div id="players"></div>
        </div>
        <div class="panel">
          <strong>Finish Order</strong>
          <ol id="finish"></ol>
        </div>
        <div class="panel">
          <strong>온라인 플레이(베타)</strong>
          <div style="display:flex; gap:8px; margin:8px 0">
            <button id="btnHost" class="ghost">호스트</button>
            <button id="btnJoin" class="ghost">게스트</button>
          </div>
          <small style="color:var(--muted)">SDP 코드를 복사/붙여넣기로 연결합니다(서버 없이 P2P).</small>
          <div style="margin-top:8px">
            <textarea id="sdpIn" placeholder="상대 코드 붙여넣기" style="width:100%; height:80px; border-radius:12px; padding:8px; border:1px solid #e5e9ff"></textarea>
            <textarea id="sdpOut" placeholder="내 코드" style="width:100%; height:80px; border-radius:12px; padding:8px; border:1px solid #e5e9ff; margin-top:6px" readonly></textarea>
            <div style="display:flex; gap:6px; margin-top:6px">
              <button id="btnApply" class="ghost">코드 적용</button>
              <span class="badge" id="netBadge">오프라인</span>
            </div>
          </div>
        </div>
      </aside>
    </div>

    <footer>
      <div>기본 룰 유지: 드로우/땡큐 → 등록·붙이기 → 버리기로 라운드를 종료하세요.</div>
      <button id="btnReset" class="ghost">새 게임</button>
    </footer>
  </div>

  <div class="toast" id="toast" style="display:none"></div>

<script>
// ====== Card / Deck utils ======
const SUITS = ['♠','♥','♦','♣'];
const RANKS = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
const BOT_NAMES = ['Bot α','Bot β','Bot γ','Bot δ','Bot ε','Bot ζ'];
const isRed = s => s==='♥' || s==='♦';

function buildDeck(){
  const deck=[]; let id=0;
  for(const s of SUITS){ for(const r of RANKS){ deck.push({ id: String(id++), suit: s, rank: r }); } }
  return shuffle(deck);
}
function shuffle(a){ for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]];} return a; }
function rankValue(r){ if(r==='A') return 1; if(r==='J') return 11; if(r==='Q') return 12; if(r==='K') return 13; return parseInt(r,10); }
function sortByRank(cards){ return [...cards].sort((a,b)=>rankValue(a.rank)-rankValue(b.rank)); }

// ====== Meld validation ======
function isSet(cards){ if(cards.length<3) return false; const r = cards[0].rank; return cards.every(c=>c.rank===r); }
function isRun(cards){
  if(cards.length<3) return false; const suit=cards[0].suit; if(!cards.every(c=>c.suit===suit)) return false;
  const sorted = sortByRank(cards);
  let ok = true; for(let i=1;i<sorted.length;i++){ if(rankValue(sorted[i].rank)!==rankValue(sorted[i-1].rank)+1) { ok=false; break; } }
  if(ok) return true;
  const mapHigh = x=> x.rank==='A'?14:rankValue(x.rank);
  const s2 = [...cards].sort((a,b)=>mapHigh(a)-mapHigh(b));
  ok=true; for(let i=1;i<s2.length;i++){ if(mapHigh(s2[i])!==mapHigh(s2[i-1])+1){ ok=false; break; } }
  return ok;
}
function canAttach(card, meld){
  if(meld.kind==='seven') return false; // 7 단독 등록에는 붙일 수 없음
  if(meld.kind==='set'){
    const cs = [...meld.cards, card];
    return isSet(cs);
  }
  if(meld.kind==='run'){
    return canAttachRunEnds(card, meld.cards);
  }
  return false;
}
function canAttachRunEnds(card, runCards){
  // 붙이기는 "양 끝"에만 허용. 중간 삽입 금지.
  if(runCards.length<3) return false;
  const suit = runCards[0].suit;
  if(!runCards.every(c=>c.suit===suit)) return false;
  if(card.suit!==suit) return false;
  const mapLow = x=> rankValue(x.rank);
  const mapHigh = x=> x.rank==='A'?14:rankValue(x.rank);
  const numsLow = [...runCards].map(mapLow).sort((a,b)=>a-b);
  const numsHigh = [...runCards].map(mapHigh).sort((a,b)=>a-b);
  const isConsecutive = (arr)=> arr.every((v,i)=> i===0 || v===arr[i-1]+1);
  let allow=false;
  const vLow = mapLow(card);
  const vHigh = mapHigh(card);
  if(isConsecutive(numsLow)){
    const lowMin = numsLow[0], lowMax = numsLow[numsLow.length-1];
    if(vLow===lowMin-1 || vLow===lowMax+1) allow=true;
  }
  if(!allow && isConsecutive(numsHigh)){
    const hiMin = numsHigh[0], hiMax = numsHigh[numsHigh.length-1];
    if(vHigh===hiMin-1 || vHigh===hiMax+1) allow=true;
  }
  return allow && isRun([...runCards, card]);
}
function classifyMeld(cards){
  if(cards.length===1 && cards[0].rank==='7') return { kind:'seven', cards:[...cards] };
  if(isSet(cards)) return { kind:'set', cards: sortByRank(cards) };
  if(isRun(cards)) return { kind:'run', cards: sortByRank(cards) };
  return null;
}

// ====== State ======
const state = {
  deck: [],
  discard: [],
  melds: [],
  players: [],
  turnIndex: 0,
  phase: 'choose-source', // choose-source | action | gameover
  finishOrder: [],
  options: { continueAfterOut: true },
  seatCount: 4,
  round: 1,
  mustUseThankYouCardId: null,
  ty: { open:false, claimant:null, fromPlayerId:null, cardId:null }, // 땡큐 선착순 락
};

function localPlayerId(){
  if (typeof net !== 'undefined' && net.online){
    return net.isHost ? 'P1' : 'P2';
  }
  return 'P1';
}

function localPlayer(){
  return state.players.find((p)=>p.id===localPlayerId()) || state.players[0];
}

function localPlayerIndex(){
  const idx = state.players.findIndex((p)=>p.id===localPlayerId());
  return idx >= 0 ? idx : 0;
}

function newGame(seatCount){
  const fallback = state.seatCount ?? 4;
  const numeric = Number(seatCount ?? fallback);
  const sanitized = Number.isFinite(numeric) ? numeric : fallback;
  const desired = Math.min(6, Math.max(3, sanitized));
  state.seatCount = desired;
  state.deck = buildDeck();
  state.discard = [];
  state.melds = [];
  state.players = [];
  const addPlayer = (cfg) => {
    state.players.push({ id: `P${state.players.length + 1}`, hand: [], status: 'active', ...cfg });
  };
  const localName = net.online ? (net.isHost ? 'You(Host)' : 'You') : 'You';
  addPlayer({ name: localName, isBot: false });
  if (net.online) {
    addPlayer({ name: net.isHost ? 'Guest' : 'Host', isBot: false });
  }
  let botCursor = 0;
  while (state.players.length < desired) {
    addPlayer({ name: BOT_NAMES[botCursor % BOT_NAMES.length], isBot: true });
    botCursor += 1;
  }
  state.turnIndex = 0;
  state.phase = 'choose-source';
  state.finishOrder = [];
  state.round = 1;
  state.mustUseThankYouCardId = null;
  state.ty = { open: false, claimant: null, fromPlayerId: null, cardId: null };
  pendingDiscard = null;
  selected.clear();
  for (let i = 0; i < 7; i += 1) {
    state.players.forEach((p) => {
      if (p.status === 'active') {
        p.hand.push(state.deck.pop());
      }
    });
  }
  if (state.deck.length > 0) {
    state.discard.push(state.deck.pop());
  }
  const logEl = document.getElementById('log');
  if (logEl) logEl.innerHTML = '';
  drawUI();
  logMsg(`게임 시작! ${desired}명 테이블.`);
  maybeBotTurn();
}

function current(){ return state.players[state.turnIndex]; }
function nextActiveIndex(from){ const n=state.players.length; for(let k=1;k<=n;k++){ const idx=(from+k)%n; if(state.players[idx].status==='active') return idx; } return from; }

// ====== Rules helpers ======
function legalThankYouFor(player){
  const top = state.discard[state.discard.length-1]; if(!top) return {allowed:false};
  if(!state.ty.open) return {allowed:false};
  // 본인이 방금 버린 카드는 땡큐 불가
  if(state.ty.fromPlayerId===player.id) return {allowed:false};
  // 드로우/땡큐 중복 금지: 현재 턴의 phase가 choose-source가 아니어도, 땡큐는 인터럽트로 허용하지만 즉시 사용 가능한 경우만
  // 등록/붙이기 가능 여부 검사
  // 테이블 붙이기 체크
  for(let i=0;i<state.melds.length;i++){ if(canAttach(top, state.melds[i])) return {allowed:true, card:top, mode:'attach'}; }
  // 등록 체크 (7 단독 포함)
  const trial = [...player.hand, top];
  const combos = kComb(trial, 1, 5);
  for(const c of combos){ const m=classifyMeld(c); if(m && c.some(x=>x.id===top.id)) return {allowed:true, card:top, mode:'register'}; }
  return {allowed:false};
}

function kComb(arr, minK=3, maxK=5){
  const res=[]; const n=arr.length; const max=Math.min(maxK,n);
  function rec(start, combo){
    if(combo.length>=minK) res.push([...combo]);
    if(combo.length===max) return;
    for(let i=start;i<n;i++){ combo.push(arr[i]); rec(i+1, combo); combo.pop(); }
  }
  rec(0,[]); return res;
}

function afterAnyAction(player){
  if(player.status==='active' && player.hand.length===0){
    player.status='out'; state.finishOrder.push(player.id);
    showToast(`${player.name} 아웃!`);
    state.mustUseThankYouCardId=null;
    state.ty={open:false, claimant:null, fromPlayerId:null, cardId:null};
    if(!state.options.continueAfterOut){ state.phase='gameover'; drawUI(); return true; }
    const left = state.players.filter(p=>p.status==='active').length;
    if(left<=1){
      const last = state.players.find(p=>p.status==='active');
      if(last){ last.status='out'; state.finishOrder.push(last.id); }
      state.phase='gameover'; drawUI(); return true;
    }
    const idxNow = state.turnIndex;
    if(state.players[idxNow].id===player.id){ state.turnIndex = nextActiveIndex(idxNow); state.phase='choose-source'; }
  }
  return false;
}

function endTurn(){
  state.turnIndex = nextActiveIndex(state.turnIndex);
  state.phase='choose-source';
  state.mustUseThankYouCardId=null;
  // 턴 넘어가면 땡큐 창 닫힘(선착순 창은 버린 직후에만)
  state.ty={open:false, claimant:null, fromPlayerId:null, cardId:null};
}

// ====== Actions ======
function drawFromDeck(){
  const p=current(); if(state.phase!=='choose-source') return;
  if(state.deck.length===0){ reshuffleFromDiscard(); }
  if(state.deck.length===0) { logMsg('덱 고갈!'); return; }
  const fromRect = document.getElementById('deckZone').getBoundingClientRect();
  const newCard = state.deck.pop();
  p.hand.push(newCard);
  state.phase='action';
  // 드로우한 순간에는 땡큐 창 닫음 (드로우를 선택했으므로)
  state.ty.open=false;
  drawUI();
  const targetEl = document.querySelector(`#hand .card[data-id="${newCard.id}"]`);
  if(targetEl){ const toRect = targetEl.getBoundingClientRect(); flyCard(fromRect, toRect, newCard); }
}

function claimThankYou(playerIndex){
  const player = state.players[playerIndex];
  const chk = legalThankYouFor(player); if(!chk.allowed) return false;
  if(!state.ty.open) return false;
  if(state.ty.claimant && state.ty.claimant!==player.id) return false; // 이미 다른 사람이 먹음
  // 선착순 집행
  state.ty.claimant = player.id;
  const topEl = document.querySelector('#discardCards .card');
  const fromRect = topEl? topEl.getBoundingClientRect() : document.getElementById('discardZone').getBoundingClientRect();
  const top=state.discard.pop(); player.hand.push(top);
  state.mustUseThankYouCardId = top.id; // 반드시 즉시 사용
  state.phase = (playerIndex===state.turnIndex) ? 'action' : state.phase; // 인터럽트지만 자신의 phase 강제하진 않음
  showToast(`땡큐! ${player.name} 선점 ✅`);
  drawUI();
  const targetEl = document.querySelector(`#hand .card[data-id="${top.id}"]`);
  if(targetEl){ const toRect = targetEl.getBoundingClientRect(); flyCard(fromRect, toRect, top); }
  // 땡큐 창 닫음(선착순)
  state.ty.open=false;
  return true;
}

function takeThankYou(){ // UI에서 내 입장(0번 플레이어)
  claimThankYou(localPlayerIndex());
}

function registerSelected(kind){
  const p=current(); if(state.phase==='choose-source'){ showToast('먼저 드로우 또는 땡큐'); return; }
  const sel = selectedFromHand(); if(sel.length<1){ showToast('카드를 선택하세요'); return; }
  if(state.mustUseThankYouCardId && !sel.some(c=>c.id===state.mustUseThankYouCardId)){
    showToast('땡큐 카드부터 사용해야 해요'); return;
  }
  const m = classifyMeld(sel);
  if(!m){ showToast('유효하지 않은 조합'); return; }
  if(kind==='set' && m.kind!=='set') { showToast('세트 아님'); return; }
  if(kind==='run' && m.kind!=='run') { showToast('런 아님'); return; }
  if(m.kind==='seven' || kind===undefined || kind===m.kind){
    p.hand = p.hand.filter(c=>!sel.includes(c));
    state.melds.push(m);
    logMsg(`${p.name} 등록: ${m.kind.toUpperCase()} (${pretty(m.cards)})`);
    if(state.mustUseThankYouCardId && sel.some(c=>c.id===state.mustUseThankYouCardId)) state.mustUseThankYouCardId=null;
    clearSelection(); drawUI(); if(afterAnyAction(p)) return; return;
  }
  showToast('요청한 종류와 일치하지 않음');
}

function attachSelected(){
  const p=current(); if(state.phase==='choose-source'){ showToast('먼저 드로우 또는 땡큐'); return; }
  const sel = selectedFromHand(); if(sel.length!==1){ showToast('붙이기는 1장만 선택'); return; }
  const card=sel[0];
  if(state.mustUseThankYouCardId && card.id!==state.mustUseThankYouCardId){ showToast('땡큐 카드부터 사용해야 해요'); return; }
  for(let i=0;i<state.melds.length;i++){
    const m=state.melds[i]; if(canAttach(card,m)){
      p.hand = p.hand.filter(c=>c!==card); m.cards.push(card); m.cards = sortByRank(m.cards);
      logMsg(`${p.name} 붙이기: ${card.rank}${card.suit} → #${i+1}`);
      if(state.mustUseThankYouCardId===card.id) state.mustUseThankYouCardId=null;
      drawUI(); afterAnyAction(p); return;
    }
  }
  showToast('붙일 수 있는 곳이 없어요');
}

let pendingDiscard=null;
function setDiscard(){
  const p=current(); if(state.phase==='choose-source'){ showToast('먼저 드로우 또는 땡큐'); return; }
  if(state.mustUseThankYouCardId){ showToast('땡큐 카드 먼저 사용해야 버릴 수 있어요'); return; }
  const sel = selectedFromHand(); if(sel.length!==1){ showToast('버리기는 1장 선택'); return; }
  pendingDiscard = sel[0];
  document.getElementById('btnDiscard').disabled=false;
  drawUI();
}
function commitDiscard(){
  const p=current();
  if(state.mustUseThankYouCardId){ showToast('땡큐 카드 먼저 사용!'); return; }
  if(!pendingDiscard){ const sel=selectedFromHand(); if(sel.length===1) pendingDiscard=sel[0]; }
  if(!pendingDiscard){ showToast('버릴 카드를 1장 선택하세요'); return; }
  const fromEl = document.querySelector(`#hand .card[data-id="${pendingDiscard.id}"]`);
  const fromRect = fromEl? fromEl.getBoundingClientRect() : document.getElementById('hand').getBoundingClientRect();
  p.hand = p.hand.filter(c=>c!==pendingDiscard);
  state.discard.push(pendingDiscard); logMsg(`${p.name} 버림: ${cardText(pendingDiscard)}`);
  const justDiscarded = pendingDiscard;
  pendingDiscard=null; document.getElementById('btnDiscard').disabled=true; clearSelection();
  // 땡큐 선착순 창 오픈
  state.ty = { open:true, claimant:null, fromPlayerId:p.id, cardId:justDiscarded.id };
  drawUI();
  const topEl = document.querySelector('#discardCards .card');
  if(topEl){ const toRect = topEl.getBoundingClientRect(); flyCard(fromRect, toRect, justDiscarded); }
  // 봇이 먼저 외칠 수 있으면 즉시 선점
  autoBotThankYou(state.turnIndex);
  if(afterAnyAction(p)) return;
  endTurn(); drawUI(); maybeBotTurn();
}

function autoBotThankYou(fromIndex){
  if(!state.ty.open) return;
  const total = state.players.length;
  for(let step=1; step<total; step+=1){
    const idx = (fromIndex + step) % total;
    const bot = state.players[idx];
    if(!bot || !bot.isBot || bot.status!=='active') continue;
    const chk = legalThankYouFor(bot);
    if(chk.allowed){
      if(claimThankYou(idx)){
        botResolveForcedThankYou(idx);
      }
      break;
    }
  }
}

function botResolveForcedThankYou(botIndex){
  const bot = state.players[botIndex];
  if(!bot || !state.mustUseThankYouCardId) return;
  const forcedId = state.mustUseThankYouCardId;
  const combos = kComb(bot.hand,1,5).sort((a,b)=>b.length-a.length);
  for(const cs of combos){
    if(!cs.some(c=>c.id===forcedId)) continue;
    const m = classifyMeld(cs);
    if(m){
      bot.hand = bot.hand.filter(c=>!cs.includes(c));
      state.melds.push(m);
      logMsg(`Bot(땡큐) 등록: ${m.kind.toUpperCase()} (${pretty(m.cards)})`);
      state.mustUseThankYouCardId=null;
      drawUI();
      afterAnyAction(bot);
      return;
    }
  }
  const forcedCard = bot.hand.find(c=>c.id===forcedId);
  if(!forcedCard) return;
  for(let j=0;j<state.melds.length;j+=1){
    if(canAttach(forcedCard, state.melds[j])){
      bot.hand = bot.hand.filter(x=>x!==forcedCard);
      state.melds[j].cards.push(forcedCard);
      state.melds[j].cards=sortByRank(state.melds[j].cards);
      logMsg('Bot(땡큐) 붙이기');
      state.mustUseThankYouCardId=null;
      drawUI();
      afterAnyAction(bot);
      return;
    }
  }
}

function reshuffleFromDiscard(){
  if(state.discard.length<2) return; // keep top
  const top = state.discard.pop();
  state.deck = shuffle(state.discard); state.discard=[top];
  showToast('버린 패를 섞어 덱 보충');
}

// ====== Bot (human-like delay) ======
function maybeBotTurn(){
  const p=current(); if(!p.isBot || state.phase==='gameover') return;
  const delay = (ms)=>new Promise(res=>setTimeout(res, ms));
  (async()=>{ await delay(300 + Math.random()*500); await botActAsync(delay); })();
}
async function botActAsync(delay){
  const p=current(); if(!p.isBot || p.status!=='active') return;
  if(state.phase==='choose-source'){
    await delay(200+Math.random()*400);
    // 땡큐 선점 가능 시도(자기 턴 시작에도 열려있다면)
    if(state.ty.open && !state.ty.claimant){
      const chk = legalThankYouFor(p);
      if(chk.allowed){ claimThankYou(state.turnIndex); drawUI(); return botActAsync(delay); }
    }
    drawFromDeck(); drawUI(); return botActAsync(delay);
  }
  const tryRegister = async () => {
    const combos = kComb(p.hand,1,5).sort((a,b)=>b.length-a.length);
    for(const cs of combos){ const m=classifyMeld(cs); if(m){
      await delay(220+Math.random()*380);
      p.hand = p.hand.filter(c=>!cs.includes(c)); state.melds.push(m);
      logMsg(`Bot 등록: ${m.kind.toUpperCase()} (${pretty(m.cards)})`);
      drawUI(); if(afterAnyAction(p)) return true; return tryRegister();
    }} return false;
  };
  if(await tryRegister()) return;
  for(let i=0;i<p.hand.length;i++){
    const c=p.hand[i];
    for(let j=0;j<state.melds.length;j++){
      if(canAttach(c,state.melds[j])){
        await delay(180+Math.random()*300);
        p.hand.splice(i,1); state.melds[j].cards.push(c); state.melds[j].cards=sortByRank(state.melds[j].cards);
        logMsg(`Bot 붙이기: ${cardText(c)} → #${j+1}`);
        drawUI(); if(afterAnyAction(p)) return; i=-1; break;
      }
    }
  }
  await delay(220+Math.random()*380);
  let candIndex=0, bestScore=-1;
  for(let i=0;i<p.hand.length;i++){
    const c=p.hand[i];
    const rv=rankValue(c.rank); const suitScore = p.hand.filter(x=>x.suit===c.suit).length;
    const rankScore = p.hand.filter(x=>x.rank===c.rank).length;
    const score = rv + (1/(suitScore||1))*4 + (1/(rankScore||1))*6;
    if(score>bestScore){bestScore=score; candIndex=i;}
  }
  const dc = p.hand.splice(candIndex,1)[0]; state.discard.push(dc); logMsg(`Bot 버림: ${cardText(dc)}`);
  // 땡큐 창 오픈
  state.ty = { open:true, claimant:null, fromPlayerId:p.id, cardId:dc.id };
  drawUI(); if(afterAnyAction(p)) return; endTurn(); drawUI();
}

// ====== UI ======
function drawUI(){
  document.getElementById('opt-continue').checked = state.options.continueAfterOut;
  const seatSelect = document.getElementById('seatCount');
  if (seatSelect){
    seatSelect.value = String(state.seatCount);
    if (typeof net !== 'undefined'){
      seatSelect.disabled = net.online && !net.isHost;
      seatSelect.title = seatSelect.disabled ? '온라인 게스트는 좌석을 변경할 수 없습니다.' : '';
    }
  }
  const turnPlayer = current();
  document.getElementById('turnBadge').textContent = `턴: ${turnPlayer?.name ?? '-'}`;
  document.getElementById('roundInfo').textContent = `R${state.round}${state.phase==='gameover'?' · 게임끝':''}`;

  const deckCount = document.getElementById('deckCount'); deckCount.textContent = `남은 장수: ${state.deck.length}`;

  const dc = document.getElementById('discardCards'); dc.innerHTML='';
  const top = state.discard[state.discard.length-1]; if(top) { const el=cardEl(top,false); el.classList.add('enter'); dc.appendChild(el); }

  const mwrap = document.getElementById('melds'); mwrap.innerHTML='';
  state.melds.forEach((m,i)=>{
    const d=document.createElement('div'); d.className='meld enter';
    const title=document.createElement('div'); title.style.fontSize='12px'; title.style.color='var(--muted)';
    title.textContent = `#${i+1} · ${m.kind.toUpperCase()} (${m.cards.length})`;
    const row=document.createElement('div'); row.className='cards';
    m.cards.forEach(c=>{ const el=cardEl(c,false); el.classList.add('enter'); row.appendChild(el); });
    d.appendChild(title); d.appendChild(row); mwrap.appendChild(d);
  });

  const h = document.getElementById('hand'); h.innerHTML='';
  const me = localPlayer();
  if (me){
    me.hand.sort((a,b)=> (a.suit===b.suit? rankValue(a.rank)-rankValue(b.rank) : a.suit.localeCompare(b.suit)));
    me.hand.forEach(c=> { const el=cardEl(c,true); el.classList.add('enter'); h.appendChild(el); });
  }

  const plist=document.getElementById('players'); plist.innerHTML='';
  const myId = me?.id;
  state.players.forEach((p, idx)=>{
    const line=document.createElement('div');
    line.className='player-row';
    if(idx===state.turnIndex) line.classList.add('active');
    if(p.status!=='active') line.classList.add('out');
    const nameWrap=document.createElement('div'); nameWrap.className='name';
    const title=document.createElement('strong'); title.textContent = `${idx+1}번 · ${p.name}`;
    const role=document.createElement('span'); role.textContent = p.isBot ? '봇 플레이어' : (p.id===myId ? '나' : '플레이어');
    nameWrap.appendChild(title); nameWrap.appendChild(role);
    const meta=document.createElement('div'); meta.className='meta';
    meta.textContent = p.status==='active' ? `패 ${p.hand.length}장` : 'OUT';
    line.appendChild(nameWrap);
    line.appendChild(meta);
    plist.appendChild(line);
  });

  const f=document.getElementById('finish'); f.innerHTML='';
  state.finishOrder.forEach((pid,idx)=>{
    const li=document.createElement('li'); const nm = state.players.find(p=>p.id===pid)?.name||pid; li.textContent = `${idx+1}등 · ${nm}`; f.appendChild(li);
  });

  const meTurn = me && current().id===me.id && me.status==='active' && state.phase!=='gameover';
  document.getElementById('btnDraw').disabled = !meTurn || state.phase!=='choose-source';
  // 땡큐 버튼: 선착순 창 열려 있고, 내가 선점 안 당했고, 즉시 사용 가능해야 함
  const tyCheck = me ? legalThankYouFor(me) : { allowed:false };
  const tyBtn=document.getElementById('btnTY');
  tyBtn.disabled = !(state.ty.open && (!state.ty.claimant || state.ty.claimant===me?.id) && tyCheck.allowed);
  tyBtn.classList.toggle('pulse', !tyBtn.disabled);
  updateDiscardButtonState();
}

function cardEl(card, selectable){
  const d=document.createElement('div'); d.className='card'; d.dataset.id=card.id;
  if(selectable){
    if(selected.has(card.id)) d.classList.add('selected');
    d.addEventListener('click',()=>toggleSelect(card.id,d));
  }
  const inner=document.createElement('div'); inner.className='inner';
  const rank=document.createElement('div'); rank.className='rank ' + (isRed(card.suit)?'red':'black'); rank.textContent=card.rank;
  const suit=document.createElement('div'); suit.className='suit ' + (isRed(card.suit)?'red':'black'); suit.textContent=card.suit;
  inner.appendChild(rank); inner.appendChild(suit); d.appendChild(inner); return d;
}

const selected = new Set();
function toggleSelect(id, el){ if(selected.has(id)){ selected.delete(id); el.classList.remove('selected'); } else { selected.add(id); el.classList.add('selected'); } updateDiscardButtonState(); }
function selectedFromHand(){ const me=localPlayer(); if(!me) return []; const ids=[...selected]; const out=[]; ids.forEach(id=>{ const c=me.hand.find(x=>x.id===id); if(c) out.push(c); }); return out; }
function clearSelection(){ selected.clear(); updateDiscardButtonState(); }

// ====== UX helpers ======
function flyCard(fromRect, toRect, card){
  const f=document.createElement('div'); f.className='flycard';
  const r=document.createElement('div'); r.className='flyrank'; r.textContent=card.rank; r.style.color=(isRed(card.suit)?'#e34d5c':'#2b2f3a');
  const s=document.createElement('div'); s.className='flysuit'; s.textContent=card.suit; s.style.color=(isRed(card.suit)?'#e34d5c':'#2b2f3a');
  f.appendChild(r); f.appendChild(s);
  document.body.appendChild(f);
  const startX = fromRect.left + (fromRect.width/2) - 35;
  const startY = fromRect.top + (fromRect.height/2) - 49;
  f.style.transform = `translate(${startX}px, ${startY}px)`; f.style.opacity = .7;
  f.getBoundingClientRect();
  const endX = toRect.left + (toRect.width/2) - 35;
  const endY = toRect.top + (toRect.height/2) - 49;
  requestAnimationFrame(()=>{ f.style.transform = `translate(${endX}px, ${endY}px)`; f.style.opacity=1; });
  setTimeout(()=>{ f.remove(); }, 300);
}
function showToast(message, ms=1200){
  const t = document.getElementById('toast'); if(!t){ console.warn('toast element missing'); return; }
  t.textContent = message; t.style.display = 'block';
  clearTimeout(window.__toastTimer); window.__toastTimer = setTimeout(()=>{ t.style.display='none'; }, ms);
}
function logMsg(msg){ const l=document.getElementById('log'); if(!l){ console.log('[LOG]', msg); return; } const line=document.createElement('div'); line.textContent=msg; l.appendChild(line); l.scrollTop=l.scrollHeight; }
function cardText(c){ return `${c.rank}${c.suit}`; }
function pretty(cards){ return cards.map(cardText).join(' '); }
function updateDiscardButtonState(){
  const btn = document.getElementById('btnDiscard');
  const me = localPlayer();
  const meTurn = me && current().id===me.id && me.status==='active' && state.phase!=='gameover';
  const one = selectedFromHand().length===1;
  btn.disabled = !(meTurn && state.phase!=='choose-source' && one && !state.mustUseThankYouCardId);
}

// ====== Networking (P2P WebRTC, copy-paste SDP) ======
const net = { role:null, pc:null, dc:null, online:false, isHost:false };
const netBadge = ()=>document.getElementById('netBadge');

async function hostStart(){
  net.role='host'; net.isHost=true; net.pc=new RTCPeerConnection();
  net.dc = net.pc.createDataChannel('hoola');
  wireDataChannel(net.dc);
  const offer = await net.pc.createOffer(); await net.pc.setLocalDescription(offer);
  document.getElementById('sdpOut').value = btoa(JSON.stringify(net.pc.localDescription));
  net.pc.onicecandidate = (e)=>{ if(!e.candidate){ document.getElementById('sdpOut').value = btoa(JSON.stringify(net.pc.localDescription)); }}
}
async function guestStart(){
  net.role='guest'; net.isHost=false; net.pc=new RTCPeerConnection();
  net.pc.ondatachannel = (e)=>{ net.dc=e.channel; wireDataChannel(net.dc); };
  const offerStr = document.getElementById('sdpIn').value.trim(); if(!offerStr) return showToast('호스트 코드를 붙여넣으세요');
  const offer = JSON.parse(atob(offerStr));
  await net.pc.setRemoteDescription(offer);
  const answer = await net.pc.createAnswer(); await net.pc.setLocalDescription(answer);
  document.getElementById('sdpOut').value = btoa(JSON.stringify(net.pc.localDescription));
  net.pc.onicecandidate = (e)=>{ if(!e.candidate){ document.getElementById('sdpOut').value = btoa(JSON.stringify(net.pc.localDescription)); }}
}
async function hostApplyAnswer(){ const ansStr = document.getElementById('sdpIn').value.trim(); if(!ansStr) return showToast('게스트 코드를 붙여넣으세요'); const ans = JSON.parse(atob(ansStr)); await net.pc.setRemoteDescription(ans); }
function wireDataChannel(dc){
  dc.onopen=()=>{ net.online=true; netBadge().textContent='온라인'; netBadge().style.background='#eaffea'; netBadge().style.color='#137a13';
    if(net.isHost){ newGame(state.seatCount); sendSnapshot(); }
    else { drawUI(); }
  };
  dc.onmessage=(e)=>{
    const msg = JSON.parse(e.data);
    if(msg.t==='snapshot'){ Object.assign(state, msg.state); selected.clear(); pendingDiscard=null; drawUI(); return; }
    if(!net.isHost){ return; }
    handleRemoteAction(msg);
  };
}
function sendSnapshot(){ if(net.online && net.dc?.readyState==='open'){ net.dc.send(JSON.stringify({t:'snapshot', state})); }}
function sendAction(a){ if(net.online && net.dc?.readyState==='open'){ net.dc.send(JSON.stringify(a)); }}

function handleRemoteAction(a){
  // 호스트가 선착순 판정 및 모든 검증을 수행
  switch(a.t){
    case 'draw': if(current().id==='P2') { drawFromDeck(); drawUI(); } break;
    case 'thankyou-claim': {
      // 원격도 선착순
      if(state.ty.open && !state.ty.claimant){
        const idx = state.players.findIndex(p=>p.id==='P2');
        claimThankYou(idx);
        drawUI();
      }
    } break;
    case 'register': {
      if(current().id!=='P2' || state.phase==='gameover') break;
      const idx = state.players.findIndex(pl=>pl.id==='P2');
      if(idx<0) break;
      const p = state.players[idx];
      const cards = p.hand.filter(c=>a.ids.includes(c.id));
      if(state.mustUseThankYouCardId && !cards.some(c=>c.id===state.mustUseThankYouCardId)) break;
      const m = classifyMeld(cards);
      if(!m) break; if(a.kind && m.kind!==a.kind) break;
      p.hand = p.hand.filter(c=>!cards.includes(c)); state.melds.push(m); logMsg(`Remote 등록: ${m.kind}`);
      if(state.mustUseThankYouCardId && cards.some(c=>c.id===state.mustUseThankYouCardId)) state.mustUseThankYouCardId=null;
      drawUI();
      afterAnyAction(p);
    } break;
    case 'attach': {
      if(current().id!=='P2' || state.phase==='gameover') break;
      const idx = state.players.findIndex(pl=>pl.id==='P2');
      if(idx<0) break;
      const p=state.players[idx]; const card=p.hand.find(c=>c.id===a.id); if(!card) break;
      if(state.mustUseThankYouCardId && card.id!==state.mustUseThankYouCardId) break;
      let targetIndex = -1; for(let j=0;j<state.melds.length;j++){ if(canAttach(card, state.melds[j])) { targetIndex=j; break; } }
      if(targetIndex>=0){
        const m=state.melds[targetIndex]; p.hand=p.hand.filter(x=>x!==card); m.cards.push(card); m.cards=sortByRank(m.cards); logMsg('Remote 붙이기');
        if(state.mustUseThankYouCardId===card.id) state.mustUseThankYouCardId=null; drawUI(); afterAnyAction(p);
      }
    } break;
    case 'discard': {
      if(current().id!=='P2' || state.phase==='gameover') break;
      if(state.mustUseThankYouCardId) break;
      const idx = state.players.findIndex(pl=>pl.id==='P2');
      if(idx<0) break;
      const p=state.players[idx]; const card=p.hand.find(c=>c.id===a.id); if(!card) break; p.hand=p.hand.filter(x=>x!==card); state.discard.push(card);
      state.ty = { open:true, claimant:null, fromPlayerId:p.id, cardId:card.id };
      autoBotThankYou(idx);
      if(afterAnyAction(p)) break;
      endTurn();
      drawUI();
      maybeBotTurn();
    } break;
  }
  sendSnapshot();
}

// ====== Events ======
const elDraw=document.getElementById('btnDraw');
const elTY=document.getElementById('btnTY');
const elRegSet=document.getElementById('btnRegSet');
const elRegRun=document.getElementById('btnRegRun');
const elAttach=document.getElementById('btnAttach');
const elPendDiscard=document.getElementById('btnDiscard');
const elReset=document.getElementById('btnReset');
const seatSelect=document.getElementById('seatCount');

const isRemoteClient = ()=> typeof net !== 'undefined' && net.online && !net.isHost;
const localId = ()=> localPlayerId();

elDraw.onclick=()=>{
  if(isRemoteClient()){
    if(current().id===localId()) sendAction({t:'draw'});
  } else {
    if(current().id===localId()) { drawFromDeck(); sendSnapshot(); }
  }
};
elTY.onclick=()=>{
  if(isRemoteClient()){
    sendAction({t:'thankyou-claim'});
  }
  else { takeThankYou(); sendSnapshot(); }
};
elRegSet.onclick=()=>{
  const ids = selectedFromHand().map(c=>c.id);
  if(isRemoteClient()){
    if(current().id===localId()) sendAction({t:'register', kind:'set', ids});
  } else { registerSelected('set'); sendSnapshot(); }
};
elRegRun.onclick=()=>{
  const ids = selectedFromHand().map(c=>c.id);
  if(isRemoteClient()){
    if(current().id===localId()) sendAction({t:'register', kind:'run', ids});
  } else { registerSelected('run'); sendSnapshot(); }
};
elAttach.onclick=()=>{
  const sel = selectedFromHand();
  if(isRemoteClient()){
    if(current().id===localId()){
      if(sel.length===1) sendAction({t:'attach', id: sel[0].id});
      else showToast('붙이기는 1장만 선택');
    }
  } else { attachSelected(); sendSnapshot(); }
};

document.getElementById('hand').addEventListener('dblclick', ()=>{ if(!isRemoteClient()) setDiscard(); });
elPendDiscard.onclick=()=>{
  if(isRemoteClient()){
    if(current().id===localId()){
      const sel = selectedFromHand(); if(sel.length===1) sendAction({t:'discard', id: sel[0].id});
      else showToast('버릴 카드를 1장 선택하세요');
    }
  } else { commitDiscard(); sendSnapshot(); }
};
if(seatSelect){
  seatSelect.addEventListener('change',(e)=>{
    const next = Number(e.target.value);
    if(isRemoteClient()){
      showToast('온라인 플레이 중에는 좌석을 변경할 수 없어요');
      drawUI();
      return;
    }
    newGame(next);
    sendSnapshot();
  });
}

document.getElementById('opt-continue').addEventListener('change', (e)=>{ state.options.continueAfterOut = e.target.checked; sendSnapshot(); });

elReset.onclick=()=>{ newGame(); sendSnapshot(); };

document.getElementById('btnHost').onclick=()=>hostStart();
document.getElementById('btnJoin').onclick=()=>guestStart();
document.getElementById('btnApply').onclick=()=>hostApplyAnswer();

// ====== Unit Tests (lightweight) ======
function runUnitTests(){
  const results=[]; const rec=(name,ok,detail='')=>{ results.push({name,ok,detail}); (ok?console.log:console.error)(ok?`PASS: ${name}`:`FAIL: ${name} — ${detail}`); };
  try{ rec('isSet valid 5x3', isSet([{rank:'5',suit:'♣'},{rank:'5',suit:'♥'},{rank:'5',suit:'♦'}])); }catch(e){ rec('isSet valid 5x3', false, e.message); }
  try{ rec('isSet invalid len<3', !isSet([{rank:'5',suit:'♣'},{rank:'5',suit:'♥'}])); }catch(e){ rec('isSet invalid len<3', false, e.message); }
  try{ rec('isSet invalid mismatch', !isSet([{rank:'5',suit:'♣'},{rank:'5',suit:'♥'},{rank:'6',suit:'♦'}])); }catch(e){ rec('isSet invalid mismatch', false, e.message); }
  try{ rec('isRun 5-6-7 ♥', isRun([{rank:'5',suit:'♥'},{rank:'6',suit:'♥'},{rank:'7',suit:'♥'}])); }catch(e){ rec('isRun 5-6-7 ♥', false, e.message); }
  try{ rec('isRun A-2-3 ♣ (low ace)', isRun([{rank:'A',suit:'♣'},{rank:'2',suit:'♣'},{rank:'3',suit:'♣'}])); }catch(e){ rec('isRun A-2-3 low', false, e.message); }
  try{ rec('isRun Q-K-A ♦ (high ace)', isRun([{rank:'Q',suit:'♦'},{rank:'K',suit:'♦'},{rank:'A',suit:'♦'}])); }catch(e){ rec('isRun Q-K-A high', false, e.message); }
  try{ rec('isRun no wrap K-A-2 ♠', !isRun([{rank:'K',suit:'♠'},{rank:'A',suit:'♠'},{rank:'2',suit:'♠'}])); }catch(e){ rec('isRun no wrap', false, e.message); }
  try{ const m = classifyMeld([{rank:'7',suit:'♣'}]); rec('classify single 7 → seven', m && m.kind==='seven'); }catch(e){ rec('classify seven', false, e.message); }
  try{ const setM = {kind:'set', cards:[{rank:'5',suit:'♥'},{rank:'5',suit:'♦'},{rank:'5',suit:'♠'}]}; rec('attach 5♣ to set', canAttach({rank:'5',suit:'♣'}, setM)); }catch(e){ rec('attach to set', false, e.message); }
  try{ const runM = {kind:'run', cards: sortByRank([{rank:'2',suit:'♥'},{rank:'3',suit:'♥'},{rank:'4',suit:'♥'}])}; rec('attach 5♥ to run end', canAttach({rank:'5',suit:'♥'}, runM)); }catch(e){ rec('attach to run end 5', false, e.message); }
  try{ const runM2 = {kind:'run', cards: sortByRank([{rank:'3',suit:'♥'},{rank:'4',suit:'♥'},{rank:'5',suit:'♥'}])}; rec('attach 2♥ to run start', canAttach({rank:'2',suit:'♥'}, runM2)); }catch(e){ rec('attach to run start 2', false, e.message); }
  try{ const runM3 = {kind:'run', cards: sortByRank([{rank:'3',suit:'♥'},{rank:'4',suit:'♥'},{rank:'5',suit:'♥'}])}; rec('attach 6♥ to run end', canAttach({rank:'6',suit:'♥'}, runM3)); }catch(e){ rec('attach to run end 6', false, e.message); }
  try{ const runM4 = {kind:'run', cards: sortByRank([{rank:'3',suit:'♥'},{rank:'4',suit:'♥'},{rank:'5',suit:'♥'}])}; rec('attach 4♥ (middle) not allowed', !canAttach({rank:'4',suit:'♥'}, runM4)); }catch(e){ rec('attach to run middle 4', false, e.message); }
  try{ const sevenM = {kind:'seven', cards:[{rank:'7',suit:'♣'}]}; rec('cannot attach to solo seven', !canAttach({rank:'6',suit:'♣'}, sevenM)); }catch(e){ rec('seven attach rule', false, e.message); }
  // ThankYou race: open & claimant null, two claim attempts -> first wins
  try{
    const tmp=JSON.parse(JSON.stringify(state));
    state.players=[{id:'P1',name:'A',isBot:false,hand:[],status:'active'},{id:'P2',name:'B',isBot:false,hand:[],status:'active'}];
    state.discard=[{id:'X',rank:'7',suit:'♣'}];
    state.melds=[]; state.phase='choose-source';
    state.ty={open:true, claimant:null, fromPlayerId:'P2', cardId:'X'};
    // Give P1 a helping card to register 7 solo
    const preLen = state.players[0].hand.length;
    const c1 = claimThankYou(0);
    const c2 = claimThankYou(1);
    rec('thankyou first-come wins', c1===true && c2===false && state.players[0].hand.length===preLen+1);
    Object.assign(state,tmp);
  }catch(e){ rec('thankyou race rule', false, e.message); }
  const ok = results.filter(r=>r.ok).length; const total = results.length; logMsg(`테스트: ${ok}/${total} 성공`); results.filter(r=>!r.ok).forEach(r=>logMsg(`❌ ${r.name} ${r.detail?'- '+r.detail:''}`));
}

runUnitTests();

// boot
newGame();
</script>
</body>
</html>
